<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Forecast Aggregator</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <h1>üå§Ô∏è Weather Forecast Aggregator</h1>
            <p class="subtitle">Real-time weather data from multiple global forecast APIs</p>
        </header>

        <div class="controls">
            <div class="location-selector">
                <span class="location-icon">üìç</span>
                <select id="location" onchange="loadForecast()">
                    <option value="Tel Aviv" selected>Tel Aviv</option>
                    <option value="Jerusalem">Jerusalem</option>
                    <option value="Haifa">Haifa</option>
                    <option value="Beer Sheva">Beer Sheva</option>
                </select>
                <span class="dropdown-arrow">‚ñº</span>
            </div>
            <button id="refresh-btn" class="refresh-btn" onclick="refreshForecast()">
                <span class="refresh-icon">üîÑ</span>
                <span class="refresh-text">Refresh</span>
            </button>
        </div>

        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Fetching forecasts from all sources...</p>
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="last-updated" class="last-updated" style="display: none;">
            Last updated: <span id="update-time"></span>
        </div>

        <div id="day-tabs" class="day-tabs" style="display: none;"></div>

        <div id="forecast-container">
            <div id="aggregated-forecast" class="forecast-section">
                <h2>üìä Aggregated Forecast</h2>
                <div id="aggregated-days" class="forecast-days"></div>
            </div>

            <div id="raw-data-section" style="display: none;">
                <button onclick="toggleRawData()" class="toggle-btn">üìã Show Individual Sources</button>
                <div id="raw-data" class="raw-data" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        let forecastData = null;
        let currentDayIndex = 0;
        let touchStartX = 0;
        let touchEndX = 0;

        // Weather icon mapping based on conditions
        function getWeatherIcon(condition, cloudCover) {
            if (!condition) {
                // Fallback to cloud cover if no condition provided
                if (cloudCover !== null && cloudCover !== undefined) {
                    if (cloudCover < 20) return '‚òÄÔ∏è';
                    if (cloudCover < 50) return 'üå§Ô∏è';
                    if (cloudCover < 75) return '‚õÖ';
                    return '‚òÅÔ∏è';
                }
                return 'üå§Ô∏è';
            }

            const cond = condition.toLowerCase();
            if (cond.includes('clear') || cond.includes('sunny')) return '‚òÄÔ∏è';
            if (cond.includes('partly') || cond.includes('partial')) return 'üå§Ô∏è';
            if (cond.includes('cloud')) return '‚òÅÔ∏è';
            if (cond.includes('rain') || cond.includes('shower')) return 'üåßÔ∏è';
            if (cond.includes('thunder') || cond.includes('storm')) return '‚õàÔ∏è';
            if (cond.includes('snow') || cond.includes('blizzard')) return '‚ùÑÔ∏è';
            if (cond.includes('fog') || cond.includes('mist')) return 'üå´Ô∏è';
            if (cond.includes('wind')) return 'üí®';
            return 'üå§Ô∏è';
        }

        // Get weather description
        function getWeatherDescription(condition, cloudCover, precipProb) {
            if (condition) return condition;

            // Generate description from data
            let desc = '';
            if (cloudCover < 20) desc = 'Clear';
            else if (cloudCover < 50) desc = 'Partly Cloudy';
            else if (cloudCover < 75) desc = 'Mostly Cloudy';
            else desc = 'Overcast';

            if (precipProb && precipProb > 30) {
                desc += ' with rain likely';
            } else if (precipProb && precipProb > 10) {
                desc += ' with possible rain';
            }

            return desc;
        }

        // Refresh forecast function
        async function refreshForecast() {
            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.classList.add('refreshing');
            refreshBtn.disabled = true;

            // Clear cache by forcing new load
            forecastData = null;
            await loadForecast(true);

            refreshBtn.classList.remove('refreshing');
            refreshBtn.disabled = false;
        }

        // Create day tabs
        function createDayTabs(days) {
            const dayTabsContainer = document.getElementById('day-tabs');
            dayTabsContainer.innerHTML = '';
            dayTabsContainer.style.display = 'flex';

            days.forEach((day, index) => {
                const tab = document.createElement('div');
                tab.className = 'day-tab' + (index === currentDayIndex ? ' active' : '');
                tab.textContent = formatDate(day.date);
                tab.onclick = () => scrollToDay(index);
                dayTabsContainer.appendChild(tab);
            });
        }

        // Scroll to specific day
        function scrollToDay(index) {
            currentDayIndex = index;
            const dayCards = document.querySelectorAll('.day-card');
            if (dayCards[index]) {
                dayCards[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                updateActiveDayTab();
            }
        }

        // Update active day tab
        function updateActiveDayTab() {
            const tabs = document.querySelectorAll('.day-tab');
            tabs.forEach((tab, index) => {
                tab.classList.toggle('active', index === currentDayIndex);
            });
        }

        // Load forecast on page load
        window.onload = function() {
            loadForecast();

            // Make the entire location selector clickable
            const locationSelector = document.querySelector('.location-selector');
            const locationSelect = document.getElementById('location');
            const dropdownArrow = document.querySelector('.dropdown-arrow');

            locationSelector.addEventListener('click', function(e) {
                // Only trigger if not already clicking on the select itself
                if (e.target !== locationSelect) {
                    locationSelect.focus();
                    locationSelect.click();
                }
            });

            // Rotate arrow on focus/blur
            locationSelect.addEventListener('focus', function() {
                dropdownArrow.style.transform = 'rotate(180deg)';
            });

            locationSelect.addEventListener('blur', function() {
                dropdownArrow.style.transform = 'rotate(0deg)';
            });

            // Add touch swipe support for mobile
            const forecastContainer = document.getElementById('aggregated-days');
            forecastContainer.addEventListener('touchstart', handleTouchStart, false);
            forecastContainer.addEventListener('touchend', handleTouchEnd, false);
        };

        // Touch swipe handlers
        function handleTouchStart(e) {
            touchStartX = e.changedTouches[0].screenX;
        }

        function handleTouchEnd(e) {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }

        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchStartX - touchEndX;

            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0 && currentDayIndex < forecastData.aggregated.length - 1) {
                    // Swipe left - next day
                    scrollToDay(currentDayIndex + 1);
                } else if (diff < 0 && currentDayIndex > 0) {
                    // Swipe right - previous day
                    scrollToDay(currentDayIndex - 1);
                }
            }
        }

        async function loadForecast(forceRefresh = false) {
            const location = document.getElementById('location').value;
            const loadingDiv = document.getElementById('loading');
            const errorDiv = document.getElementById('error');
            const forecastContainer = document.getElementById('forecast-container');

            // Show loading
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';
            forecastContainer.style.display = 'none';

            try {
                // Initial request
                const response = await fetch(`/api/forecast?location=${encodeURIComponent(location)}`);
                const data = await response.json();

                if (data.status === 'success') {
                    // Data is cached and ready
                    displayForecast(data.data);
                } else {
                    // Data is loading, poll for status
                    pollStatus();
                }
            } catch (error) {
                showError('Failed to load forecast: ' + error.message);
            }
        }

        async function pollStatus() {
            const maxAttempts = 60; // 60 seconds max
            let attempts = 0;

            const interval = setInterval(async () => {
                attempts++;

                if (attempts > maxAttempts) {
                    clearInterval(interval);
                    showError('Timeout: Failed to fetch forecast data');
                    return;
                }

                try {
                    const response = await fetch('/api/status');
                    const data = await response.json();

                    if (data.status === 'ready') {
                        clearInterval(interval);
                        displayForecast(data.data);
                    }
                } catch (error) {
                    clearInterval(interval);
                    showError('Failed to check status: ' + error.message);
                }
            }, 1000); // Poll every second
        }

        function displayForecast(data) {
            const loadingDiv = document.getElementById('loading');
            const forecastContainer = document.getElementById('forecast-container');
            const aggregatedDays = document.getElementById('aggregated-days');
            const lastUpdated = document.getElementById('last-updated');
            const updateTime = document.getElementById('update-time');

            loadingDiv.style.display = 'none';
            forecastContainer.style.display = 'block';
            lastUpdated.style.display = 'block';
            updateTime.textContent = new Date().toLocaleString();

            forecastData = data;

            // Create day tabs
            createDayTabs(data.aggregated);

            // Display aggregated forecast
            aggregatedDays.innerHTML = '';
            data.aggregated.forEach(day => {
                const dayCard = createDayCard(day, true);
                aggregatedDays.appendChild(dayCard);
            });

            // Show raw data toggle if we have raw data
            if (data.raw && data.raw.length > 0) {
                document.getElementById('raw-data-section').style.display = 'block';
            }
        }

        function createDayCard(day, isAggregated) {
            const card = document.createElement('div');
            card.className = 'day-card';

            const confidence = isAggregated ? day.confidence : null;
            const confidenceClass = confidence ? getConfidenceClass(confidence) : '';

            // Get weather icon and description
            const weatherIcon = getWeatherIcon(day.weather_condition, day.cloud_cover);
            const weatherDesc = getWeatherDescription(day.weather_condition, day.cloud_cover, day.precipitation_prob);

            card.innerHTML = `
                <div class="day-header">
                    <div class="day-date">${formatDate(day.date)}</div>
                    ${isAggregated ? `<div class="confidence ${confidenceClass}">${Math.round(confidence)}% confidence</div>` : ''}
                </div>
                <div class="day-body">
                    <div class="weather-icon">${weatherIcon}</div>
                    <div class="weather-description">${weatherDesc}</div>
                    ${day.precipitation_prob !== null && day.precipitation_prob !== undefined ? `
                        <div class="detail-item" style="flex-direction: column; align-items: flex-start; grid-column: 1 / -1;">
                            <span style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <span class="detail-icon">üíß</span>
                                <span class="detail-label">Rain:</span>
                                <span>${Math.round(day.precipitation_prob)}%</span>
                            </span>
                            <div class="precipitation-bar" style="width: 100%;">
                                <div class="precipitation-fill" style="width: ${day.precipitation_prob}%;"></div>
                            </div>
                        </div>
                    ` : ''}
                    <div class="temps">
                        <div class="temp-high">
                            <span class="temp-label">High</span>
                            <span class="temp-value">${day.temp_high ? Math.round(day.temp_high) + '¬∞C' : 'N/A'}</span>
                            ${day.feels_like_high ? `<span class="temp-label" style="font-size: 0.8em; margin-top: 4px;">Feels ${Math.round(day.feels_like_high)}¬∞C</span>` : ''}
                        </div>
                        <div class="temp-low">
                            <span class="temp-label">Low</span>
                            <span class="temp-value">${day.temp_low ? Math.round(day.temp_low) + '¬∞C' : 'N/A'}</span>
                            ${day.feels_like_low ? `<span class="temp-label" style="font-size: 0.8em; margin-top: 4px;">Feels ${Math.round(day.feels_like_low)}¬∞C</span>` : ''}
                        </div>
                    </div>
                    <div class="details">
                        <div class="detail-item">
                            <span class="detail-icon">üí®</span>
                            <span class="detail-label">Wind:</span>
                            <span>${day.wind_speed ? Math.round(day.wind_speed) + ' km/h' : 'N/A'} ${day.wind_direction || ''}</span>
                        </div>
                        ${day.humidity !== null && day.humidity !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-icon">üíß</span>
                            <span class="detail-label">Humidity:</span>
                            <span>${Math.round(day.humidity)}%</span>
                        </div>
                        ` : ''}
                        <div class="detail-item">
                            <span class="detail-icon">‚òÅÔ∏è</span>
                            <span class="detail-label">Cloud Cover:</span>
                            <span>${day.cloud_cover ? formatCloudCover(day.cloud_cover, day.cloud_min_level) : 'N/A'}</span>
                        </div>
                        ${day.freezing_altitude ? `
                        <div class="detail-item">
                            <span class="detail-icon">‚ùÑÔ∏è</span>
                            <span class="detail-label">Freezing Level:</span>
                            <span>${Math.round(day.freezing_altitude)}m</span>
                        </div>
                        ` : ''}
                        <div class="detail-item">
                            <span class="detail-icon">üåÖ</span>
                            <span class="detail-label">Sunrise:</span>
                            <span>${day.sunrise || 'N/A'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-icon">üåá</span>
                            <span class="detail-label">Sunset:</span>
                            <span>${day.sunset || 'N/A'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-icon">üåî</span>
                            <span class="detail-label">Moonrise:</span>
                            <span>${day.moonrise || 'N/A'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-icon">üåë</span>
                            <span class="detail-label">Moonset:</span>
                            <span>${day.moonset || 'N/A'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-icon">üåô</span>
                            <span class="detail-label">Moon Phase:</span>
                            <span>${day.moon_illumination ? Math.round(day.moon_illumination) + '%' : 'N/A'}</span>
                        </div>
                    </div>
                    ${day.hourly && day.hourly.length > 0 ? `
                    <div class="hourly-section">
                        <button class="hourly-toggle" onclick="toggleHourly(this)">
                            üìä Show 3-Hourly Forecast ‚ñº
                        </button>
                        <div class="hourly-data" style="display: none;">
                            <div class="hourly-grid">
                                ${day.hourly.map(h => `
                                    <div class="hourly-item">
                                        <div class="hourly-time">${h.time}</div>
                                        ${h.weather_condition ? `<div style="text-align: center; font-size: 1.5em; margin: 5px 0;">${getWeatherIcon(h.weather_condition, h.cloud_cover)}</div>` : ''}
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">üå°Ô∏è</span>
                                            <span>${h.temperature ? Math.round(h.temperature) + '¬∞C' : 'N/A'}</span>
                                        </div>
                                        ${h.feels_like ? `
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">ü§ö</span>
                                            <span>Feels ${Math.round(h.feels_like)}¬∞C</span>
                                        </div>
                                        ` : ''}
                                        ${h.precipitation_prob !== null && h.precipitation_prob !== undefined ? `
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">üíß</span>
                                            <span>${Math.round(h.precipitation_prob)}% rain</span>
                                        </div>
                                        ` : ''}
                                        ${h.humidity !== null && h.humidity !== undefined ? `
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">üí¶</span>
                                            <span>${Math.round(h.humidity)}% humid</span>
                                        </div>
                                        ` : ''}
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">üí®</span>
                                            <span>${h.wind_speed ? Math.round(h.wind_speed) + ' km/h' : 'N/A'} ${h.wind_direction || ''}</span>
                                        </div>
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">‚òÅÔ∏è</span>
                                            <span>${h.cloud_cover !== null && h.cloud_cover !== undefined ? (Math.round(h.cloud_cover / 12.5) + '/8' + (h.cloud_base && h.cloud_base > 0 ? ' alt ' + Math.round(h.cloud_base * 3.28084).toLocaleString() + ' ft' : '')) : 'N/A'}</span>
                                        </div>
                                        ${h.freezing_altitude ? `
                                        <div class="hourly-detail">
                                            <span class="hourly-icon">‚ùÑÔ∏è</span>
                                            <span>${Math.round(h.freezing_altitude)}m</span>
                                        </div>
                                        ` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    ${isAggregated && day.sources_used ? `
                    <div class="sources">
                        Sources: ${day.sources_used.join(', ')}
                    </div>
                    ` : ''}
                    ${!isAggregated && day.source ? `
                    <div class="source-badge">${day.source}</div>
                    ` : ''}
                </div>
            `;

            return card;
        }

        function formatCloudCover(cloudPercent, cloudBase) {
            // Convert percentage to octas (eighths)
            const octas = Math.round(cloudPercent / 12.5);
            let result = `${octas}/8`;

            // Add altitude only if real data available (not estimated)
            if (cloudBase && cloudBase > 0) {
                const altitudeFt = Math.round(cloudBase * 3.28084);
                result += ` alt ${altitudeFt.toLocaleString()} ft`;
            }

            return result;
        }

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            if (date.toDateString() === today.toDateString()) {
                return 'Today';
            } else if (date.toDateString() === tomorrow.toDateString()) {
                return 'Tomorrow';
            } else {
                return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
            }
        }

        function getConfidenceClass(confidence) {
            if (confidence >= 80) return 'high';
            if (confidence >= 60) return 'medium';
            return 'low';
        }

        function toggleRawData() {
            const rawDataDiv = document.getElementById('raw-data');
            const toggleBtn = document.querySelector('.toggle-btn');

            if (rawDataDiv.style.display === 'none') {
                // Show raw data
                rawDataDiv.style.display = 'block';
                toggleBtn.textContent = 'üìã Hide Individual Sources';

                // Populate raw data
                rawDataDiv.innerHTML = '<h3>Individual Source Forecasts</h3>';
                const sources = {};

                // Group by source
                forecastData.raw.forEach(day => {
                    if (!sources[day.source]) {
                        sources[day.source] = [];
                    }
                    sources[day.source].push(day);
                });

                // Display each source
                Object.entries(sources).forEach(([source, days]) => {
                    const sourceSection = document.createElement('div');
                    sourceSection.className = 'source-section';
                    sourceSection.innerHTML = `<h4>${source}</h4><div class="forecast-days"></div>`;

                    const daysContainer = sourceSection.querySelector('.forecast-days');
                    days.forEach(day => {
                        const dayCard = createDayCard(day, false);
                        daysContainer.appendChild(dayCard);
                    });

                    rawDataDiv.appendChild(sourceSection);
                });
            } else {
                rawDataDiv.style.display = 'none';
                toggleBtn.textContent = 'üìã Show Individual Sources';
            }
        }

        function toggleHourly(button) {
            const hourlyData = button.nextElementSibling;
            if (hourlyData.style.display === 'none') {
                hourlyData.style.display = 'block';
                button.textContent = 'üìä Hide 3-Hourly Forecast ‚ñ≤';
            } else {
                hourlyData.style.display = 'none';
                button.textContent = 'üìä Show 3-Hourly Forecast ‚ñº';
            }
        }

        function showError(message) {
            const loadingDiv = document.getElementById('loading');
            const errorDiv = document.getElementById('error');

            loadingDiv.style.display = 'none';
            errorDiv.style.display = 'block';
            errorDiv.textContent = message;
        }
    </script>
</body>
</html>
